
{
  ".gitignore": "# build output\ndist/\n# generated types\n.astro/\n\n# dependencies\nnode_modules/\n\n# logs\nnpm-debug.log*\nyarn-debug.log*\nyarn-error.log*\npnpm-debug.log*\n\n\n# environment variables\n.env\n.env.production\n\n# macOS-specific files\n.DS_Store\n",
  "astro.config.mjs": "import { defineConfig } from 'astro/config';\nimport tailwind from \"@astrojs/tailwind\";\n\nimport react from \"@astrojs/react\";\n\n// https://astro.build/config\nexport default defineConfig({\n  integrations: [tailwind(), react()]\n});",
  "package.json": "{\n  \"name\": \"@example/basics\",\n  \"type\": \"module\",\n  \"version\": \"0.0.1\",\n  \"private\": true,\n  \"scripts\": {\n    \"dev\": \"astro dev\",\n    \"start\": \"astro dev\",\n    \"build\": \"astro build\",\n    \"preview\": \"astro preview\",\n    \"astro\": \"astro\"\n  },\n  \"dependencies\": {\n    \"@astrojs/alpinejs\": \"^0.1.3\",\n    \"@astrojs/mdx\": \"^2.0.3\",\n    \"@astrojs/react\": \"^3.0.9\",\n    \"@astrojs/sitemap\": \"^1.0.1\",\n    \"@astrojs/tailwind\": \"^5.1.0\",\n    \"@fontsource/inter\": \"^4.5.14\",\n    \"@fortawesome/fontawesome-svg-core\": \"^6.5.1\",\n    \"@fortawesome/free-solid-svg-icons\": \"^6.5.1\",\n    \"@fortawesome/react-fontawesome\": \"^0.2.0\",\n    \"@types/alpinejs\": \"^3.7.1\",\n    \"@types/react\": \"^18.2.55\",\n    \"@types/react-dom\": \"^18.2.18\",\n    \"astro\": \"^4.1.1\",\n    \"astro-color-scheme\": \"^1.0.1\",\n    \"astro-feather-icons\": \"^1.0.2\",\n    \"astro-icon\": \"^0.8.0\",\n    \"astro-seo\": \"^0.6.1\",\n    \"css-box-model\": \"^1.2.1\",\n    \"mdast-util-to-string\": \"^3.1.0\",\n    \"react\": \"^18.2.0\",\n    \"react-dom\": \"^18.2.0\",\n    \"reading-time\": \"^1.5.0\",\n    \"rehype-plugin-image-native-lazy-loading\": \"^1.2.0\",\n    \"tailwindcss\": \"^3.2.4\"\n  },\n  \"devDependencies\": {\n    \"@tailwindcss/line-clamp\": \"^0.4.2\",\n    \"@tailwindcss/typography\": \"^0.5.9\",\n    \"classnames\": \"^2.3.2\",\n    \"sharp\": \"^0.31.3\"\n  }\n}\n",
  "tailwind.config.mjs": "/** @type {import('tailwindcss').Config} */\nconst colors = require(\"tailwindcss/colors\");\nconst defaultTheme = require(\"tailwindcss/defaultTheme\");\nmodule.exports = {\n    content: [\"./src/**/*.{astro,html,js,jsx,md,mdx,svelte,ts,tsx,vue}\"],\n    darkMode: \"class\",\n    theme: {\n        extend: {\n            colors: {\n                gray: colors.neutral,\n                primary: '#CD5334', // red\n                secondary: '#2E282A', // black\n                teal: '17BEBB', // teal\n                buff: '#EDB88B', // buff\n                rose: '#FAD8D6', // rose\n            },\n            fontFamily: {\n                sans: [\"InterVariable\", \"Inter\", ...defaultTheme.fontFamily.sans],\n            },\n            aspectRatio: {\n                \"4/3\": \"4 / 3\",\n                \"3/2\": \"3 / 2\",\n                \"2/3\": \"2 / 3\",\n                \"9/16\": \"9 / 16\",\n            },\n        },\n    },\n    plugins: [\n        require(\"@tailwindcss/line-clamp\"),\n        require(\"@tailwindcss/typography\"),\n    ],\n};\n",
  "tsconfig.json": "{\n  \"extends\": \"astro/tsconfigs/base\",\n  \"compilerOptions\": {\n    \"jsx\": \"react-jsx\",\n    \"jsxImportSource\": \"react\"\n  }\n}",
  "src/env.d.ts": "/// <reference path=\"../.astro/types.d.ts\" />\n/// <reference types=\"astro/client\" />\n",
  "src/pages/index.astro": "---\nimport Page from '../layouts/Page.astro';\n---\n<Page>\n  <h1>Hello, world!</h1>\n</Page>\n\n",
  "src/pages/blog/[...slug].astro": "---\nimport Page from '../../layouts/Page.astro';\nimport { CollectionEntry, getCollection } from 'astro:content';\n\nexport async function getStaticPaths() {\n\tconst posts = await getCollection('blog');\n\treturn posts\n        .map((post) => ({\n            params: { slug: post.slug },\n            props: post,\n        }));\n}\ntype Props = CollectionEntry<'blog'>;\n\nconst post = Astro.props;\nconst { Content } = await post.render();\n\n\n\n\n\n---\n\n<Page>\n    <div class=\"m-10\">\n      <h1 class=\"text-lg\">{post.data.title}</h1>\n      <Content />\n      <a class=\"text-green-500 hover:text-green-600\" href=\"/blog\">\n          Back to blog\n      </a>\n    </div>\n</Page>\n",
  "src/pages/blog/index.astro": "---\nimport Page from '../../layouts/Page.astro';\nimport { getCollection } from 'astro:content';\n\nconst posts = await getCollection('blog');\nconsole.log(posts);\n\n---\n\n<Page>\n<div class=\"m-10\">\n  <ul>\n    {posts.map((post) => (\n      <li class=\"text-blue-500 hover:text-blue-600\">\n        <a href={`/blog/${post.slug}`}>{post.data.title}</a>\n      </li>\n    ))}\n  </ul>\n</div>\n</Page>\n",
  "src/layouts/Page.astro": "---\ninterface Menu {\n  label: string;\n  href: string;\n  external?: boolean;\n  badge?: string;\n}\n\nconst rightmenu: Menu[] = [\n  {\n    label: \"Archive\",\n    href: \"/archive\",\n  },\n  {\n    label: \"Blog\",\n    href: \"/blog\",\n  },\n  {\n    label: \"Github\",\n    href: \"https://github.com/web3templates/stablo-astro\",\n    external: true,\n    badge: \"new\",\n  },\n  {\n    label: \"Download\",\n    href: \"https://web3templates.com/templates/stablo-minimal-blog-website-template\",\n    external: true,\n  },\n];\n\nconst rightmenuColor = \"text-gray-400 dark:text-gray-400 hover:text-blue-500\";\n\n---\n\n<html lang=\"en\">\n\t<head>\n\t\t<meta charset=\"utf-8\" />\n\t\t<link rel=\"icon\" type=\"image/svg+xml\" href=\"/favicon.svg\" />\n\t\t<meta name=\"viewport\" content=\"width=device-width\" />\n\t\t<meta name=\"generator\" content={Astro.generator} />\n\t\t<title>Astro</title>\n\t</head>\n\t<body class=\"m-10\">\n<div class=\"mb-10\">\n  {\n    rightmenu.map((item) => (\n      <a\n        href={item.href}\n        class=`px-5 py-2 text-sm font-medium ${rightmenuColor}`>\n        {item.label}\n      </a>\n      ))\n  }\n</div>\n    <slot />\n\n\t</body>\n</html>\n",
  "src/content/config.ts": "import { defineCollection, z } from 'astro:content';\n\nconst blog = defineCollection({\n  // Type-check frontmatter using a schema\n  schema: z.object({\n    title: z.string(),\n    description: z.string(),\n    // Transform string to Date object\n    pubDate: z\n      .string()\n      .or(z.date())\n      .transform((val) => new Date(val)),\n    draft: z.boolean().optional().default(true),\n    updatedDate: z\n      .string()\n      .optional()\n      .transform((str) => (str ? new Date(str) : undefined)),\n    heroImage: z.string().optional(),\n    tags: z.array(z.string()).optional().default([]),\n  }),\n});\n\nexport const collections = {\n  blog,\n};\n",
  "src/content/blog/file1.md": "---\ntitle: Article 1\npubDate: 2024-01-28\ndescription: helloooo\ndraft: false\n---\n\nThis is article 1.\n",
  "src/content/blog/file2.md": "---\ntitle: Article 2\npubDate: 2024-01-28\ndescription: helloooo\ndraft: false\n---\n\nThis is article 2.\n",
  "src/content/blog/file3.md": "---\ntitle: Article 3\npubDate: 2024-01-28\ndescription: helloooo\ndraft: false\n---\n\nThis is article 3.\n",
  "public/favicon.svg": "<svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 128 128\">\n    <path d=\"M50.4 78.5a75.1 75.1 0 0 0-28.5 6.9l24.2-65.7c.7-2 1.9-3.2 3.4-3.2h29c1.5 0 2.7 1.2 3.4 3.2l24.2 65.7s-11.6-7-28.5-7L67 45.5c-.4-1.7-1.6-2.8-2.9-2.8-1.3 0-2.5 1.1-2.9 2.7L50.4 78.5Zm-1.1 28.2Zm-4.2-20.2c-2 6.6-.6 15.8 4.2 20.2a17.5 17.5 0 0 1 .2-.7 5.5 5.5 0 0 1 5.7-4.5c2.8.1 4.3 1.5 4.7 4.7.2 1.1.2 2.3.2 3.5v.4c0 2.7.7 5.2 2.2 7.4a13 13 0 0 0 5.7 4.9v-.3l-.2-.3c-1.8-5.6-.5-9.5 4.4-12.8l1.5-1a73 73 0 0 0 3.2-2.2 16 16 0 0 0 6.8-11.4c.3-2 .1-4-.6-6l-.8.6-1.6 1a37 37 0 0 1-22.4 2.7c-5-.7-9.7-2-13.2-6.2Z\" />\n    <style>\n        path { fill: #000; }\n        @media (prefers-color-scheme: dark) {\n            path { fill: #FFF; }\n        }\n    </style>\n</svg>\n",
  ".astro/types.d.ts": "declare module 'astro:content' {\n\tinterface Render {\n\t\t'.md': Promise<{\n\t\t\tContent: import('astro').MarkdownInstance<{}>['Content'];\n\t\t\theadings: import('astro').MarkdownHeading[];\n\t\t\tremarkPluginFrontmatter: Record<string, any>;\n\t\t}>;\n\t}\n}\n\ndeclare module 'astro:content' {\n\texport { z } from 'astro/zod';\n\n\ttype Flatten<T> = T extends { [K: string]: infer U } ? U : never;\n\n\texport type CollectionKey = keyof AnyEntryMap;\n\texport type CollectionEntry<C extends CollectionKey> = Flatten<AnyEntryMap[C]>;\n\n\texport type ContentCollectionKey = keyof ContentEntryMap;\n\texport type DataCollectionKey = keyof DataEntryMap;\n\n\t// This needs to be in sync with ImageMetadata\n\texport type ImageFunction = () => import('astro/zod').ZodObject<{\n\t\tsrc: import('astro/zod').ZodString;\n\t\twidth: import('astro/zod').ZodNumber;\n\t\theight: import('astro/zod').ZodNumber;\n\t\tformat: import('astro/zod').ZodUnion<\n\t\t\t[\n\t\t\t\timport('astro/zod').ZodLiteral<'png'>,\n\t\t\t\timport('astro/zod').ZodLiteral<'jpg'>,\n\t\t\t\timport('astro/zod').ZodLiteral<'jpeg'>,\n\t\t\t\timport('astro/zod').ZodLiteral<'tiff'>,\n\t\t\t\timport('astro/zod').ZodLiteral<'webp'>,\n\t\t\t\timport('astro/zod').ZodLiteral<'gif'>,\n\t\t\t\timport('astro/zod').ZodLiteral<'svg'>,\n\t\t\t\timport('astro/zod').ZodLiteral<'avif'>,\n\t\t\t]\n\t\t>;\n\t}>;\n\n\ttype BaseSchemaWithoutEffects =\n\t\t| import('astro/zod').AnyZodObject\n\t\t| import('astro/zod').ZodUnion<[BaseSchemaWithoutEffects, ...BaseSchemaWithoutEffects[]]>\n\t\t| import('astro/zod').ZodDiscriminatedUnion<string, import('astro/zod').AnyZodObject[]>\n\t\t| import('astro/zod').ZodIntersection<BaseSchemaWithoutEffects, BaseSchemaWithoutEffects>;\n\n\ttype BaseSchema =\n\t\t| BaseSchemaWithoutEffects\n\t\t| import('astro/zod').ZodEffects<BaseSchemaWithoutEffects>;\n\n\texport type SchemaContext = { image: ImageFunction };\n\n\ttype DataCollectionConfig<S extends BaseSchema> = {\n\t\ttype: 'data';\n\t\tschema?: S | ((context: SchemaContext) => S);\n\t};\n\n\ttype ContentCollectionConfig<S extends BaseSchema> = {\n\t\ttype?: 'content';\n\t\tschema?: S | ((context: SchemaContext) => S);\n\t};\n\n\ttype CollectionConfig<S> = ContentCollectionConfig<S> | DataCollectionConfig<S>;\n\n\texport function defineCollection<S extends BaseSchema>(\n\t\tinput: CollectionConfig<S>\n\t): CollectionConfig<S>;\n\n\ttype AllValuesOf<T> = T extends any ? T[keyof T] : never;\n\ttype ValidContentEntrySlug<C extends keyof ContentEntryMap> = AllValuesOf<\n\t\tContentEntryMap[C]\n\t>['slug'];\n\n\texport function getEntryBySlug<\n\t\tC extends keyof ContentEntryMap,\n\t\tE extends ValidContentEntrySlug<C> | (string & {}),\n\t>(\n\t\tcollection: C,\n\t\t// Note that this has to accept a regular string too, for SSR\n\t\tentrySlug: E\n\t): E extends ValidContentEntrySlug<C>\n\t\t? Promise<CollectionEntry<C>>\n\t\t: Promise<CollectionEntry<C> | undefined>;\n\n\texport function getDataEntryById<C extends keyof DataEntryMap, E extends keyof DataEntryMap[C]>(\n\t\tcollection: C,\n\t\tentryId: E\n\t): Promise<CollectionEntry<C>>;\n\n\texport function getCollection<C extends keyof AnyEntryMap, E extends CollectionEntry<C>>(\n\t\tcollection: C,\n\t\tfilter?: (entry: CollectionEntry<C>) => entry is E\n\t): Promise<E[]>;\n\texport function getCollection<C extends keyof AnyEntryMap>(\n\t\tcollection: C,\n\t\tfilter?: (entry: CollectionEntry<C>) => unknown\n\t): Promise<CollectionEntry<C>[]>;\n\n\texport function getEntry<\n\t\tC extends keyof ContentEntryMap,\n\t\tE extends ValidContentEntrySlug<C> | (string & {}),\n\t>(entry: {\n\t\tcollection: C;\n\t\tslug: E;\n\t}): E extends ValidContentEntrySlug<C>\n\t\t? Promise<CollectionEntry<C>>\n\t\t: Promise<CollectionEntry<C> | undefined>;\n\texport function getEntry<\n\t\tC extends keyof DataEntryMap,\n\t\tE extends keyof DataEntryMap[C] | (string & {}),\n\t>(entry: {\n\t\tcollection: C;\n\t\tid: E;\n\t}): E extends keyof DataEntryMap[C]\n\t\t? Promise<DataEntryMap[C][E]>\n\t\t: Promise<CollectionEntry<C> | undefined>;\n\texport function getEntry<\n\t\tC extends keyof ContentEntryMap,\n\t\tE extends ValidContentEntrySlug<C> | (string & {}),\n\t>(\n\t\tcollection: C,\n\t\tslug: E\n\t): E extends ValidContentEntrySlug<C>\n\t\t? Promise<CollectionEntry<C>>\n\t\t: Promise<CollectionEntry<C> | undefined>;\n\texport function getEntry<\n\t\tC extends keyof DataEntryMap,\n\t\tE extends keyof DataEntryMap[C] | (string & {}),\n\t>(\n\t\tcollection: C,\n\t\tid: E\n\t): E extends keyof DataEntryMap[C]\n\t\t? Promise<DataEntryMap[C][E]>\n\t\t: Promise<CollectionEntry<C> | undefined>;\n\n\t/** Resolve an array of entry references from the same collection */\n\texport function getEntries<C extends keyof ContentEntryMap>(\n\t\tentries: {\n\t\t\tcollection: C;\n\t\t\tslug: ValidContentEntrySlug<C>;\n\t\t}[]\n\t): Promise<CollectionEntry<C>[]>;\n\texport function getEntries<C extends keyof DataEntryMap>(\n\t\tentries: {\n\t\t\tcollection: C;\n\t\t\tid: keyof DataEntryMap[C];\n\t\t}[]\n\t): Promise<CollectionEntry<C>[]>;\n\n\texport function reference<C extends keyof AnyEntryMap>(\n\t\tcollection: C\n\t): import('astro/zod').ZodEffects<\n\t\timport('astro/zod').ZodString,\n\t\tC extends keyof ContentEntryMap\n\t\t\t? {\n\t\t\t\t\tcollection: C;\n\t\t\t\t\tslug: ValidContentEntrySlug<C>;\n\t\t\t\t}\n\t\t\t: {\n\t\t\t\t\tcollection: C;\n\t\t\t\t\tid: keyof DataEntryMap[C];\n\t\t\t\t}\n\t>;\n\t// Allow generic `string` to avoid excessive type errors in the config\n\t// if `dev` is not running to update as you edit.\n\t// Invalid collection names will be caught at build time.\n\texport function reference<C extends string>(\n\t\tcollection: C\n\t): import('astro/zod').ZodEffects<import('astro/zod').ZodString, never>;\n\n\ttype ReturnTypeOrOriginal<T> = T extends (...args: any[]) => infer R ? R : T;\n\ttype InferEntrySchema<C extends keyof AnyEntryMap> = import('astro/zod').infer<\n\t\tReturnTypeOrOriginal<Required<ContentConfig['collections'][C]>['schema']>\n\t>;\n\n\ttype ContentEntryMap = {\n\t\t\"blog\": {\n\"file1.md\": {\n\tid: \"file1.md\";\n  slug: \"file1\";\n  body: string;\n  collection: \"blog\";\n  data: InferEntrySchema<\"blog\">\n} & { render(): Render[\".md\"] };\n\"file2.md\": {\n\tid: \"file2.md\";\n  slug: \"file2\";\n  body: string;\n  collection: \"blog\";\n  data: InferEntrySchema<\"blog\">\n} & { render(): Render[\".md\"] };\n\"file3.md\": {\n\tid: \"file3.md\";\n  slug: \"file3\";\n  body: string;\n  collection: \"blog\";\n  data: InferEntrySchema<\"blog\">\n} & { render(): Render[\".md\"] };\n};\n\n\t};\n\n\ttype DataEntryMap = {\n\t\t\n\t};\n\n\ttype AnyEntryMap = ContentEntryMap & DataEntryMap;\n\n\ttype ContentConfig = typeof import(\"../src/content/config\");\n}\n"
}
